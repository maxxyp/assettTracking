{"version":3,"sources":["hema/business/factories/readingFactory.ts"],"names":[],"mappings":"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","file":"readingFactory.js","sourcesContent":["import { IReadingFactory } from \"./interfaces/IReadingFactory\";\nimport { IReading } from \"../../api/models/fft/jobs/jobupdate/IReading\";\nimport { Appliance } from \"../models/appliance\";\nimport { ObjectHelper } from \"../../../common/core/objectHelper\";\nimport { DateHelper } from \"../../core/dateHelper\";\nimport { ApplianceSafety } from \"../models/applianceSafety\";\nimport { inject } from \"aurelia-dependency-injection\";\nimport { CatalogService } from \"../services/catalogService\";\nimport { ICatalogService } from \"../services/interfaces/ICatalogService\";\nimport { IReadTypeMapping } from \"../models/reference/IReadTypeMapping\";\nimport { IReadingType } from \"../models/reference/IReadingType\";\nimport { IPerformanceTestReason } from \"../models/reference/IPerformanceTestReason\";\n\n@inject(CatalogService)\nexport class ReadingFactory implements IReadingFactory {\n\n    private _catalogService: ICatalogService;\n\n    constructor(catalogService: ICatalogService) {\n        this._catalogService = catalogService;\n    }\n\n    public createReadingApiModels(appliance: Appliance): Promise<IReading[]> {\n        return Promise.all([\n            this._catalogService.getReadTypeMappings(),\n            this._catalogService.getReadingTypes()\n        ]).spread<IReading[]>((readTypeMappings: IReadTypeMapping[], readTypes: IReadingType[]) => {\n            let readings: IReading[] = [];\n            if (appliance && appliance.safety) {\n                return this.findReadings(appliance.safety, readTypeMappings, readTypes, readings, appliance.isCentralHeatingAppliance)\n                    .then(() => {\n                        if (appliance.safety.applianceGasSafety && appliance.safety.applianceGasSafety.performanceTestsNotDoneReason) {\n                            return this.populatePerformanceTestNotDoneReason(appliance.safety.applianceGasSafety.performanceTestsNotDoneReason, \n                                                                        readings, readTypes, appliance.isCentralHeatingAppliance);\n                        }\n                        return Promise.resolve();                                     \n                    })\n                    .then(() => {\n                        if (appliance.safety.applianceGasSafety && appliance.safety.applianceGasSafety.performanceTestsNotDoneReasonForSupplementary) {\n                            return this.populatePerformanceTestNotDoneReason(appliance.safety.applianceGasSafety.performanceTestsNotDoneReasonForSupplementary, \n                                                                        readings, readTypes, appliance.isCentralHeatingAppliance);\n                        }\n                        return Promise.resolve();  \n                    })\n                    .then(() => this.sortAndGenerateSequenceNumber(readings));\n            } \n            return Promise.resolve();\n        });\n    }\n\n    private findReadings(applianceSafety: ApplianceSafety, readTypeMappings: IReadTypeMapping[], validReadTypes: IReadingType[], readings: IReading[],\n                         isCentralHeatingAppliance: boolean): Promise<void> {\n        readTypeMappings.forEach(readType => {\n            let reading = ObjectHelper.getPathValue(applianceSafety, readType.group + \".\" + readType.id);\n            let validReadType = validReadTypes.find(x => x.readingTypeCode === readType.value);\n            if (reading !== undefined && !!validReadType) {\n                readings.push({\n                    dateTime: DateHelper.toJsonDateTimeString(new Date()),\n                    type: isCentralHeatingAppliance === true ? readType.value : readType.value.split(\"\").reverse().join(\"\"),\n                    value: reading,\n                    sequenceNumber: 0\n                });\n            }\n        });\n        return Promise.resolve();\n    }\n\n    private sortAndGenerateSequenceNumber(readings: IReading[]): IReading[] {\n        return readings.sort((a, b) => {\n            let x = DateHelper.fromJsonDateTimeString(a.dateTime);\n            let y = DateHelper.fromJsonDateTimeString(b.dateTime);\n            return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n        }).map((reading, index) => {\n            reading.sequenceNumber = ++index;\n            return reading;\n        });\n    }\n\n    // performance Test not done reasons always has value 1\n    private populatePerformanceTestNotDoneReason(performanceTestsNotDoneReason: string, readings: IReading[], validReadTypes: IReadingType[],\n        isCentralHeatingAppliance: boolean): Promise<void> {\n        return this._catalogService.getPerformanceTestReasons().then((performanceTestReasons: IPerformanceTestReason[]) => {\n            if (performanceTestReasons) {\n                let reason = performanceTestReasons.find(x => x.id === performanceTestsNotDoneReason);\n                let validReadType = validReadTypes.find(x => x.readingTypeCode === reason.id);\n                if (reason && validReadType) {\n                    if (readings === null || readings === undefined) {\n                        readings = [];\n                    }\n                    readings.push({\n                        dateTime: DateHelper.toJsonDateTimeString(new Date()),\n                        type: isCentralHeatingAppliance === true ? reason.id : reason.id.split(\"\").reverse().join(\"\"),\n                        value: validReadType.readingHighRangeValue.toString(),\n                        sequenceNumber: 0\n                    });\n                }\n            }\n            return Promise.resolve();                                        \n        });\n    }     \n}\n"],"sourceRoot":"../../.."}