{"version":3,"sources":["hema/business/factories/chargeFactory.ts"],"names":[],"mappings":"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","file":"chargeFactory.js","sourcesContent":["import { IChargeFactory } from \"./interfaces/IChargeFactory\";\nimport { Charge } from \"../models/charge/charge\";\nimport { ChargeableTask } from \"../models/charge/chargeableTask\";\nimport { ITask as TaskUpdateApiModel } from \"../../api/models/fft/jobs/jobupdate/ITask\";\nimport { ITask as TaskApiModel } from \"../../api/models/fft/jobs/ITask\";\nimport { inject } from \"aurelia-dependency-injection\";\nimport { IBusinessRuleService } from \"../services/interfaces/IBusinessRuleService\";\nimport { BusinessRuleService } from \"../services/businessRuleService\";\nimport { ICatalogService } from \"../services/interfaces/ICatalogService\";\nimport { CatalogService } from \"../services/catalogService\";\n\n@inject(BusinessRuleService, CatalogService)\nexport class ChargeFactory implements IChargeFactory {\n\n    private _businessRuleService: IBusinessRuleService;\n    private _catalogService: ICatalogService;\n    private _incompleteStatuses: string[];\n\n    constructor(businessRuleService: IBusinessRuleService, catalogService: ICatalogService) {\n        this._businessRuleService = businessRuleService;\n        this._catalogService = catalogService;\n    }\n\n    public createChargeBusinessModel(taskApiModel: TaskApiModel[]): Charge {\n        return new Charge();\n    }\n\n    public createChargeApiModel(chargeableTasks: ChargeableTask[], updateApiTasks: TaskUpdateApiModel[]): Promise<TaskUpdateApiModel[]> {\n\n        return this._businessRuleService.getQueryableRuleGroup(\"chargeFactory\").then((queryableGroup) => {\n\n            this._incompleteStatuses = queryableGroup.getBusinessRuleList<string>(\"incompleteStatuses\");\n\n            let taskPromises = updateApiTasks.map(updateApiTask => {\n\n                const chargeableTask = chargeableTasks.find(ct => {\n\n                    // if newRFA search by fieldTaskId instead of taskId\n                    if (ct.task.isNewRFA) {\n                        return ct.task.fieldTaskId === updateApiTask.fieldTaskId;\n                    }\n\n                    return ct.task.id === updateApiTask.id;\n                });\n\n                if (chargeableTask && this._incompleteStatuses.indexOf(chargeableTask.task.status) > -1) {\n                    return Promise.resolve(updateApiTask);\n                }\n\n                return this.mapChargeToTask(updateApiTask, chargeableTask);\n            });\n\n            return Promise.all(taskPromises).then(results => {\n\n                // see DF_1494, if zero charge job, still need to include subsequentJobIndicator per task for api support.\n                // if more than one task, need to flag first item as prime charge\n                // primary logic is in chargeService, but that's only for *chargeable tasks*. No charge tasks\n                // would not be added to chargeableTasks in the job business model.\n\n                const existsPrime = results.some(t => t.subsequentJobIndicator !== undefined && t.subsequentJobIndicator === false);\n\n                if (existsPrime) {\n                    return results;\n                }\n\n                results.forEach((task, index) => {\n                    // no incomplete statuses then set sub indicator, otherwise do not send across at all\n                    if (this._incompleteStatuses.indexOf(task.status) === -1) {\n                        task.subsequentJobIndicator = index > 0;\n                    }\n                });\n\n                return results;\n            });\n\n        });\n    }\n\n    private mapChargeToTask(taskApiModel: TaskUpdateApiModel, chargeableTask: ChargeableTask): Promise<TaskUpdateApiModel> {\n\n        // initialise task api\n        taskApiModel.chargeExcludingVAT = 0;\n        taskApiModel.vatAmount = 0;\n\n        if (!taskApiModel.chargeType) {\n            return Promise.resolve(taskApiModel);\n        }\n\n        return this._catalogService.getChargeType(taskApiModel.chargeType).then(ct => {\n\n            taskApiModel.vatCode = ct.vatCode;\n\n            if (!chargeableTask || !chargeableTask.task) {\n                taskApiModel.subsequentJobIndicator = true; // api still expects this even when cancelled.\n                return Promise.resolve(taskApiModel);\n            }\n\n            taskApiModel.subsequentJobIndicator = chargeableTask.isSubsequent;\n\n            if (!chargeableTask.task.isCharge) {\n                return Promise.resolve(taskApiModel);\n            }\n\n            if (chargeableTask.discountAmount) {\n                taskApiModel.discountAmount = chargeableTask.discountAmount.times(100).toNumber();\n            }\n\n            if (chargeableTask.netTotal) {\n                taskApiModel.chargeExcludingVAT = chargeableTask.netTotal.times(100).toNumber();\n            }\n\n            if (chargeableTask.vat) {\n                taskApiModel.vatAmount = chargeableTask.calculatedVatAmount.times(1000).toNumber();\n            }\n\n            if (chargeableTask.labourItem) {\n                taskApiModel.standardLabourChargeIndicator = !!chargeableTask.labourItem.isFixed;\n            }\n\n            if (chargeableTask.labourItem && chargeableTask.labourItem.netAmount) {\n                taskApiModel.totalLabourCharged = chargeableTask.labourItem.netAmount.times(100).toNumber();\n            }\n\n            return this._businessRuleService.getQueryableRuleGroup(\"chargeService\")\n                .then(ruleGroup => {\n\n                    let noDiscountCode = ruleGroup.getBusinessRule<string>(\"noDiscountCode\");\n                    if (chargeableTask.discountCode !== noDiscountCode) {\n                        taskApiModel.discountCode = chargeableTask.discountCode;\n                    }\n\n                    return Promise.resolve(taskApiModel);\n                });\n        });\n    }\n}\n"],"sourceRoot":"../../.."}