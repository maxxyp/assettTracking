{"version":3,"sources":["hema/business/services/charge/chargeCatalogHelperService.ts"],"names":[],"mappings":"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","file":"chargeCatalogHelperService.js","sourcesContent":["import * as Logging from \"aurelia-logging\";\n\nimport { ICatalogService } from \"../interfaces/ICatalogService\";\nimport { CatalogService } from \"../catalogService\";\nimport { inject } from \"aurelia-dependency-injection\";\nimport { IJcChargeRules } from \"../../models/reference/IJcChargeRules\";\nimport { IStorageService } from \"../interfaces/IStorageService\";\nimport { StorageService } from \"../storageService\";\nimport { IAreaChargeRules } from \"../../models/reference/IAreaChargeRules\";\nimport { BusinessException } from \"../../models/businessException\";\nimport { IDiscount } from \"../../models/reference/IDiscount\";\nimport { IVat } from \"../../models/reference/IVat\";\nimport * as moment from \"moment\";\nimport { IChargeCatalogHelperService } from \"../interfaces/charge/IChargeCatalogHelperService\";\nimport {IChargeType} from \"../../models/reference/IChargeType\";\n\n@inject(CatalogService, StorageService)\nexport class ChargeCatalogHelperService implements IChargeCatalogHelperService {\n\n    private _catalogService: ICatalogService;\n    private _storageService: IStorageService;\n    private _logger: Logging.Logger;\n\n    constructor(catalogService: ICatalogService,\n                storageService: IStorageService) {\n\n        this._catalogService = catalogService;\n        this._storageService = storageService;\n        this._logger = Logging.getLogger(\"ChargeCatalogHelperService\");\n    }\n\n    public getValidDiscounts(discounts: IDiscount[]): IDiscount[] {\n\n        const currentDate = moment();\n\n        if (!discounts) {\n            return [];\n        }\n        const discountsNoEndDate = discounts.filter(d => {\n            const {discountEndDate = \"\"} = d;\n            return discountEndDate === \"\";\n        });\n\n        const discountWithinDateRange = discounts.filter(d => (currentDate.isBetween(d.discountStartDate, d.discountEndDate)));\n\n        return [...discountWithinDateRange, ...discountsNoEndDate];\n    }\n\n    public getVatRate(vatCodeToCheck: string,\n                      taskStartTime: string,\n                      vatDateFormat: string,\n                      vats: IVat[]): number {\n\n        // get the vat, see if we can find one where the task date lies within the date range, if not find the current\n        // vat rate, i.e. the vat rate where the end date is empty\n\n        let vat = 0;\n\n        if (!taskStartTime) {\n            return vat;\n        }\n        const taskDate = moment(taskStartTime, vatDateFormat);\n\n        let foundVat = vats.find(vr => {\n            // being extra safe, in case api decides to omit the field all together\n            const {vatEndDate = \"\", vatCode} = vr;\n            return vatCode === vatCodeToCheck && vatEndDate === \"\";\n        });\n\n        if (!foundVat) {\n            foundVat = vats.find(vr => (moment(taskDate).isBetween(vr.vatStartDate, vr.vatEndDate)) && vr.vatCode === vatCodeToCheck);\n        }\n\n        if (!foundVat) {\n            return vat;\n        }\n\n        return foundVat.vatRate;\n    }\n\n    public async getJobCodeChargeRule(jobType: string,\n                                      applianceType: string,\n                                      chargeType: string,\n                                      chargeRulesDateFormat: string,\n                                      chargeMethodCodeLength: number): Promise<IJcChargeRules> {\n\n        const taskDate = moment(new Date());\n\n        const items = await this._catalogService.getJCChargeRules(jobType, applianceType);\n\n        let filteredItems: IJcChargeRules[] = items.filter(i => i.chargeType + i.contractType === chargeType);\n\n        // 31-dec-68 formats to the year 1968 year, 31-dec-69 formats to 2069. So that's why we have this if, else\n\n        const filteredItemsDateFormatted = filteredItems.filter(i => {\n\n            const effectiveDate = moment(i.effectiveDate, chargeRulesDateFormat);\n            const expirationDate = moment(i.expirationDate, chargeRulesDateFormat);\n\n            return taskDate.isBetween(effectiveDate, expirationDate);\n        });\n\n        // check area charge rules, there can be multiple rules per location, so we need to see if we can get a charge\n        // rule seq number. Note, we could have queried this first, but its a big table and a area charge code lookup\n        // will not be required in most cases. Check only if necessary.\n        // if more than one charge rule, assume multiple location-based charging and get rule sequence\n\n        if (!filteredItemsDateFormatted || filteredItemsDateFormatted.length === 0) {\n            return null;\n        }\n\n        // need to check that location is ok as well, see DF_1881\n        try {\n            const areaCode = await this.getAreaChargeRules(chargeType, jobType, applianceType, taskDate, chargeMethodCodeLength, chargeRulesDateFormat);\n\n            if (!areaCode) {\n                const err = new BusinessException(this, \"chargeService.getJobCodeChargeRule\", \"could not locate area charge rule\", null,\n                    `ChargeType: ${chargeType}, JobType: ${jobType}, ApplianceType: ${applianceType}`);\n\n                this._logger.error(err.toString());\n\n                return Promise.reject(err);\n            }\n            return filteredItemsDateFormatted.find(i => i.chargeRuleSequence === areaCode.chargeRuleSequence);\n        } catch (exception) {\n            return Promise.reject(exception);\n        }\n    }\n\n    public async getChargeTypesByApplianceJob(applianceType: string, jobType: string, chargeRulesDateFormat: string,\n                                              chargeMethodCodeLength: number): Promise<IChargeType[]> {\n\n        // get charge rules first to determine valid charge types\n\n        const chargeRules = await this._catalogService.getJCChargeRules(jobType, applianceType);\n\n        if (!chargeRules || chargeRules.length === 0) {\n            const ex = new BusinessException(\"context\", \"taskAppliance\",\n                `no charge rules found for appliance ${applianceType} and job type ${jobType}`, null, null);\n\n            throw(ex);\n        }\n\n        const results = chargeRules.map(cr => `${cr.chargeType}${cr.contractType}`);\n\n        const chargeTypes = await this._catalogService.getChargeTypes();\n\n        // remove dups because could be area-based charging\n        // would have preferred to use new Set(...results), but babel not configured to support this yet\n\n        const deduped = results.filter((el, i, arr) => arr.indexOf(el) === i);\n\n        return deduped.map((r: string) => chargeTypes.find(ct => ct.chargeType === r));\n\n    }\n\n    private async getAreaChargeRules(chargeType: string,\n                                     jobType: string,\n                                     applianceType: string,\n                                     taskDate: moment.Moment,\n                                     chargeMethodCodeLength: number,\n                                     chargeRulesDateFormat: string): Promise<IAreaChargeRules> {\n\n        const region = await this._storageService.getUserRegion();\n\n        if (!region) {\n            return Promise.reject(new BusinessException(this, \"chargeService\", \"No region found. Check it has been set in preferences\", null, null));\n        }\n\n        // get the charge type action code, task includes charge method, so remove\n        const ctLen = chargeType.length;\n        const appConTypeCode = chargeType.substr(chargeMethodCodeLength, ctLen);\n\n        const areaChargeRules = await this._catalogService.getAreaChargeRules(jobType, region);\n\n        let filteredItems: IAreaChargeRules[] = areaChargeRules.filter(\n            acr => {\n\n                return acr.applianceType === applianceType\n                    && acr.contractType === appConTypeCode\n                    && acr.jobType === jobType\n                    && acr.companyCode === region;\n            });\n\n        // 31-dec-68 formats to the year 1968 year, 31-dec-69 formats to 2069. So that's why we have this if, else\n\n        return filteredItems.find(i => {\n\n            const expirationDate = moment(i.expirationDate, chargeRulesDateFormat);\n            const effectiveDate = moment(i.effectiveDate, chargeRulesDateFormat);\n\n            return taskDate.isBetween(effectiveDate, expirationDate);\n        });\n    }\n}\n"],"sourceRoot":"../../../.."}