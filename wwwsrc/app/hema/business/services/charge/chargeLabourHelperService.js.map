{"version":3,"sources":["hema/business/services/charge/chargeLabourHelperService.ts"],"names":[],"mappings":"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","file":"chargeLabourHelperService.js","sourcesContent":["import * as Logging from \"aurelia-logging\";\nimport { ChargeableTask } from \"../../models/charge/chargeableTask\";\nimport { IJcChargeRules } from \"../../models/reference/IJcChargeRules\";\nimport { IPricingInterval } from \"../../models/charge/IPricingInterval\";\nimport { PrimeSubCharge } from \"../../models/charge/primeSubCharge\";\nimport { PrimePricingInterval } from \"../../models/charge/primePricingInterval\";\nimport { SubPricingInterval } from \"../../models/charge/subPricingInterval\";\nimport { ILabourChargeRule } from \"../../models/reference/ILabourChargeRule\";\nimport { IPrimeChargeInterval } from \"../../models/reference/IPrimeChargeInterval\";\nimport { ISubsqntChargeInterval } from \"../../models/reference/ISubsqntChargeInterval\";\nimport { ICatalogService } from \"../interfaces/ICatalogService\";\nimport { CatalogService } from \"../catalogService\";\nimport { inject } from \"aurelia-dependency-injection\";\nimport * as bignumber from \"bignumber\";\nimport { IChargeLabourCatalogDependencies } from \"../interfaces/charge/IChargeLabourCatalogDependencies\";\nimport { NumberHelper } from \"../../../../hema/core/numberHelper\";\n\n@inject(CatalogService)\nexport class ChargeLabourHelperService {\n\n    private _logger: Logging.Logger;\n    private _catalogService: ICatalogService;\n\n    constructor(catalogService: ICatalogService) {\n        this._catalogService = catalogService;\n        this._logger = Logging.getLogger(\"ChargeLabourHelperService\");\n    }\n\n    /**\n     *\n     * @param {ChargeableTask} chargeableTask\n     * @param {IJcChargeRules} jcChargeRule\n     * @param {IChargeLabourCatalogDependencies} catalogDependencies\n     * @returns {Promise<ChargeableTask>}\n     */\n    public async calculateLabourCharge(chargeableTask: ChargeableTask, jcChargeRule: IJcChargeRules\n        , catalogDependencies: IChargeLabourCatalogDependencies): Promise<ChargeableTask> {\n\n        const {fixedLabourChargeCurrencyUnit, tieredLabourChargeCurrencyUnit, primeChargeIntervals, subChargeIntervals}\n            = catalogDependencies;\n\n        const labourChargeRuleCode = jcChargeRule.labourChargeRuleCode;\n\n        if (!labourChargeRuleCode) {\n\n            // this is standard one off charge to apply\n            // work out both prime and sub charge, we'll find out which one to use later on when we have all the tasks,\n            // the most expensive becomes the prime task\n\n            let cp = new PrimeSubCharge(0, 0);\n\n            const primeCharge = jcChargeRule.standardLabourChargePrime;\n            const subsequentCharge = jcChargeRule.standardLabourChargeSubs;\n\n            let primeChargeVal = new bignumber.BigNumber(0);\n            let subsequentChargeVal = new bignumber.BigNumber(0);\n\n            if (!NumberHelper.isNullOrUndefined(primeCharge)) { // prime charge of 0 is valid\n                const chargeBig = new bignumber.BigNumber(primeCharge);\n                primeChargeVal = new bignumber.BigNumber(fixedLabourChargeCurrencyUnit).times(chargeBig);\n                cp.primeCharge = primeChargeVal;\n            } else {\n                cp.noPrimeChargesFound = true;\n            }\n\n            if (!NumberHelper.isNullOrUndefined(subsequentCharge)) { // sub charge of 0 is valid\n                const chargeBig = new bignumber.BigNumber(subsequentCharge);\n                subsequentChargeVal = new bignumber.BigNumber(fixedLabourChargeCurrencyUnit).times(chargeBig);\n                cp.subsequentCharge = subsequentChargeVal;\n            } else {\n                cp.noSubsequentChargesFound = true;\n            }\n\n            chargeableTask.updateLabourItem(\"\", cp, true);\n\n            this._logger.debug(\"Standard fixed price charge used\", [cp]);\n\n            return chargeableTask;\n        }\n\n        // tiered charging model, so get labour code rule and calculate charges\n        const rule = await this._catalogService.getLabourChargeRule(labourChargeRuleCode);\n        this._logger.debug(\"Labour Charge Rule found\", [rule]);\n\n        if (!rule) {\n            const message = `labour charge rule ${labourChargeRuleCode} not found in catalogData`;\n            this._logger.error(message, labourChargeRuleCode);\n            chargeableTask.setChargeableTaskAsError(message);\n            return chargeableTask;\n        }\n\n        const chargeableTime = chargeableTask.task.chargeableTime + chargeableTask.getTotalPreviousChargeableTimeForTask;\n\n        this._logger.debug(\"Chargeable time is\", [chargeableTime]);\n\n        const chargePair =\n            this.calculateChargeUsingLabourRule(rule, chargeableTime, primeChargeIntervals, subChargeIntervals);\n\n        chargePair.primeCharge = new bignumber.BigNumber(chargePair.primeCharge).times(tieredLabourChargeCurrencyUnit);\n        chargePair.subsequentCharge =\n            new bignumber.BigNumber(chargePair.subsequentCharge).times(tieredLabourChargeCurrencyUnit);\n\n        this._logger.debug(\"Tier charge calculated\", [chargePair]);\n\n        chargeableTask.updateLabourItem(\"\", chargePair, false);\n\n        return chargeableTask;\n\n    }\n\n    /**\n     *\n     * @param {number} minimumCharge\n     * @param {number} minimumPeriod\n     * @param {number} totalChargeableTime\n     * @param {IPricingInterval[]} intervals\n     * @returns {number}\n     */\n    private calculateTierCharge(minimumCharge: number, minimumPeriod: number, totalChargeableTime: number,\n                                intervals: IPricingInterval[]): number {\n\n        this._logger.debug(\"Calculate tier charge\", []);\n\n        let totalTime = totalChargeableTime - minimumPeriod;\n        let runningCharge = minimumCharge;\n\n        if (intervals && intervals.length > 0) {\n            intervals.forEach(interval => {\n\n                while (totalTime > 0) {\n                    if (totalTime > interval.chargePeriod) {\n                        runningCharge += (interval.chargePeriod / interval.chargeInterval) * interval.chargeIntervalPrice;\n                        totalTime -= interval.chargePeriod;\n                    } else {\n                        while (totalTime > 0) {\n                            runningCharge += interval.chargeIntervalPrice;\n                            totalTime -= interval.chargeInterval;\n                        }\n                    }\n                    break;\n                }\n            });\n        }\n\n        return runningCharge;\n    }\n\n    /**\n     *\n     * @param {ILabourChargeRule} labourChargeRule\n     * @param {number} totalChargeDuration\n     * @param {IPrimeChargeInterval[]} primeChargeIntervals\n     * @param {ISubsqntChargeInterval[]} subChargeIntervals\n     * @returns {PrimeSubCharge}\n     */\n    private calculateChargeUsingLabourRule(labourChargeRule: ILabourChargeRule,\n                                           totalChargeDuration: number, primeChargeIntervals: IPrimeChargeInterval[],\n                                           subChargeIntervals: ISubsqntChargeInterval[]): PrimeSubCharge {\n\n        const primeMinCharge = labourChargeRule.minimumChargeIfPrime;\n        const primeMinPeriod = labourChargeRule.minimumPdIfPrime;\n        const subMinCharge = labourChargeRule.minimumChargeIfSbsqt;\n        const subMinPeriod = labourChargeRule.minimumPdIfSbsqt;\n\n        const primeIntervals = this.mapCatalogLabourChargeRuleToPricingInterval(\n            labourChargeRule.labourChargeRuleCode, true, primeChargeIntervals, subChargeIntervals);\n\n        let primeCharge = 0;\n        let noPrimeChargesFound = false;\n\n        if (primeIntervals && primeIntervals.length > 0) {\n            this._logger.debug(\"Prime charge intervals found\", primeIntervals);\n            primeCharge = this.calculateTierCharge(primeMinCharge, primeMinPeriod, totalChargeDuration, primeIntervals);\n        } else {\n            noPrimeChargesFound = true;\n        }\n\n        let chargePair = new PrimeSubCharge(primeCharge, 0);\n        chargePair.noPrimeChargesFound = noPrimeChargesFound;\n\n        const subIntervals = this.mapCatalogLabourChargeRuleToPricingInterval(labourChargeRule.labourChargeRuleCode,\n            false, primeChargeIntervals, subChargeIntervals);\n\n        if (subIntervals && subIntervals.length > 0) {\n            this._logger.debug(\"Subsequent charge intervals found\", subIntervals);\n            const subCharge = this.calculateTierCharge(subMinCharge, subMinPeriod, totalChargeDuration, subIntervals);\n            chargePair.subsequentCharge = new bignumber.BigNumber(subCharge);\n        } else {\n            chargePair.noSubsequentChargesFound = true;\n        }\n\n        return chargePair;\n    }\n\n    /**\n     *\n     * @param {string} labourChargeRuleCode\n     * @param {boolean} isPrime\n     * @param {IPrimeChargeInterval[]} primeChargeIntervals\n     * @param {ISubsqntChargeInterval[]} subChargeIntervals\n     * @returns {IPricingInterval[]}\n     */\n    private mapCatalogLabourChargeRuleToPricingInterval(labourChargeRuleCode: string, isPrime: boolean,\n                                                        primeChargeIntervals: IPrimeChargeInterval[],\n                                                        subChargeIntervals: ISubsqntChargeInterval[]): IPricingInterval[] {\n        if (isPrime) {\n            return primeChargeIntervals.filter(item => item.labourChargeRuleCode === labourChargeRuleCode).map(item =>\n                new PrimePricingInterval(item));\n        }\n\n        return subChargeIntervals.filter(item => item.labourChargeRuleCode === labourChargeRuleCode).map(item =>\n            new SubPricingInterval(item));\n    }\n}\n"],"sourceRoot":"../../../.."}