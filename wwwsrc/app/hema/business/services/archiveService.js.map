{"version":3,"sources":["hema/business/services/archiveService.ts"],"names":[],"mappings":"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","file":"archiveService.js","sourcesContent":["import { IArchiveService } from \"./interfaces/IArchiveService\";\nimport { IHemaConfiguration } from \"../../IHemaConfiguration\";\nimport { ConfigurationService } from \"../../../common/core/services/configurationService\";\nimport { inject } from \"aurelia-dependency-injection\";\nimport { IDatabaseService } from \"../../../common/storage/IDatabaseService\";\nimport { IConfigurationService } from \"../../../common/core/services/IConfigurationService\";\nimport { Archive, ARCHIVE_DATE_FORMAT } from \"../models/archive\";\nimport { ArchiveConstants } from \"./constants/archiveConstants\";\nimport { DatabaseSchema } from \"../../../common/storage/models/databaseSchema\";\nimport { DatabaseSchemaStoreIndex } from \"../../../common/storage/models/databaseSchemaStoreIndex\";\nimport { DatabaseSchemaStore } from \"../../../common/storage/models/databaseSchemaStore\";\nimport * as moment from \"moment\";\nimport { Engineer } from \"../models/engineer\";\nimport { Job } from \"../models/job\";\nimport { ArchiveTaskItem } from \"../models/archiveTaskItem\";\nimport { JobState } from \"../models/jobState\";\nimport { ArchivePart } from \"../models/archivePart\";\nimport { ArchiveJob } from \"../models/archiveJob\";\nimport { CustomerHelper } from \"../../core/customerHelper\";\nimport { ArrayHelper } from \"../../../common/core/arrayHelper\";\nimport { DateHelper } from \"../../core/dateHelper\";\nimport { LocalStorageDbService } from \"../../../common/storage/localStorageDbService\";\nimport * as Logging from \"aurelia-logging\";\n\n/*\nUnderlying assumption is that once job is started it gets completed within the same day.\nJobs never rollover to any other day. So everthing is logged (archived) is added/updated\nunder same job for the current date.\n*/\n\n@inject(LocalStorageDbService, ConfigurationService)\nexport class ArchiveService implements IArchiveService {\n\n  private _archiveDays: number;\n  private _databaseService: IDatabaseService;\n  private _logger: Logging.Logger;\n\n  constructor(databaseService: IDatabaseService, configurationService: IConfigurationService) {\n    this._archiveDays = configurationService.getConfiguration<IHemaConfiguration>().maxDaysArchiveRetrival;\n    this._databaseService = databaseService;\n    this._logger = Logging.getLogger(\"ArchiveService\");\n  }\n\n  public async migrate(fromDb: IDatabaseService): Promise<\n                                                    \"NOTHING_TO_MIGRATE\"\n                                                    | \"MIGRATION_ALREADY_HAPPENED\"\n                                                    | \"HAVE_MIGRATED\"\n                                                    | \"MIGRATION_ERROR\"> {\n    try {\n\n        const dbSchema = this.getDbSchemDefinition();\n        const {name: databaseName, storeSchemas } = dbSchema;\n        const toDb = this._databaseService;\n\n        if (!await fromDb.exists(databaseName, storeSchemas[0].name)) {\n            this._logger.warn(\"Archive Service Migration\", \"Nothing to migrate\");\n            return \"NOTHING_TO_MIGRATE\";\n        }\n\n        if (await toDb.exists(databaseName, storeSchemas[0].name)) {\n            this._logger.warn(\"Archive Service Migration\", \"Migration already happened\");\n            return \"MIGRATION_ALREADY_HAPPENED\";\n        }\n\n        // we're good to try an migrate from old to new\n        await toDb.create(dbSchema);\n        await toDb.open(databaseName);\n        await fromDb.open(databaseName);\n\n        for (const storeSchema of storeSchemas) {\n            const existingRecords = await fromDb.getAll(databaseName, storeSchema.name);\n            await toDb.setAll(databaseName, storeSchema.name, existingRecords);\n        }\n        this._logger.warn(\"Archive Service Migration\", \"Have migrated\");\n        return \"HAVE_MIGRATED\";\n\n    } catch (error) {\n        this._logger.warn(\"Archive Service Migration\", \"Error\", error);\n        return \"MIGRATION_ERROR\";\n    }\n}\n\n  public async initialise(): Promise<void> {\n    await this.createOrOpen();\n    const items = (await this._databaseService.getAll<Archive>(ArchiveConstants.ARCHIVE_DATABASE, ArchiveConstants.ARCHIVE_STORENAME)) || [];\n    let itemsToDelete = items.filter(x => moment().diff(moment(x.timestamp), \"days\") >= this._archiveDays);\n\n    for (let itemToDelete of itemsToDelete) {\n      await this._databaseService.remove(ArchiveConstants.ARCHIVE_DATABASE, ArchiveConstants.ARCHIVE_STORENAME, itemToDelete.id);\n    }\n  }\n\n  public addEngineerState(engineer: Engineer, state: string, jobId: string): Promise<void> {\n    let archive = new Archive(engineer.id);\n    archive.jobId = jobId;\n    archive.engineerId = engineer.id;\n    archive.engineerStatus = state;\n    return this.updateEngineerStatus(archive, engineer.id, state);\n  }\n\n  public addUpdateJobState(job: Job, engineer: Engineer, jobState: JobState): Promise<void> {\n        return this.getByJob(job.id)\n            .then((archives: Archive[]) => {\n      if (archives && archives.length > 0) {\n        let existingArchive = archives.find(x => x.uniqueJobId === job.uniqueId);\n\n        // if exists and not complete then update otherwise add\n        if (existingArchive) {\n          this.populateJobState(jobState, existingArchive);\n          this.populateTasks(job, existingArchive, jobState);\n          return this.update(existingArchive);\n        } else {\n          return this.addNewArchive(job, engineer, jobState);\n        }\n      } else {\n        return this.addNewArchive(job, engineer, jobState);\n      }\n    });\n  }\n\n  public getArchiveByDate(date: string): Promise<Archive[]> {\n    return this._databaseService.getAll<Archive>(ArchiveConstants.ARCHIVE_DATABASE, ArchiveConstants.ARCHIVE_STORENAME, \"date\", date);\n  }\n\n  public async getEarliestDate(): Promise<Date> {\n    try {\n      const data = await this._databaseService.getAll<Archive>(ArchiveConstants.ARCHIVE_DATABASE, ArchiveConstants.ARCHIVE_STORENAME);\n      if (!data) {\n        return undefined;\n      }\n      const dateString = DateHelper.getMinDate(data.map(d => d.date));\n      return moment(dateString, ARCHIVE_DATE_FORMAT).toDate();\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  private addNewArchive(job: Job, engineer: Engineer, jobState: JobState): Promise<void> {\n    let archive = new Archive(engineer.id);\n    archive.jobId = job.id;\n    archive.uniqueJobId = job.uniqueId;\n    this.populateJobState(jobState, archive);\n\n    if (job.customerContact) {\n      archive.address = CustomerHelper.formatCustomerAddress(job.premises);\n      archive.customerName = CustomerHelper.formatCustomerContact(job.contact);\n    }\n    this.populateTasks(job, archive, jobState);\n    return this.update(archive);\n  }\n\n  private populateJobState(newState: JobState, archive: Archive): void {\n    if (!archive.jobStates) {\n      archive.jobStates = [];\n    }\n\n    let newArchiveJob = new ArchiveJob();\n    newArchiveJob.state = newState;\n    if (newState === JobState.enRoute) {\n      // user may select / de-select job multiple times\n      // so we will remove previously selected job state.\n      archive.jobStates = [];\n    }\n    if (!archive.jobStates.find(x => x.state === newArchiveJob.state)) {\n      archive.jobStates.push(newArchiveJob);\n    }\n        let newJobStates = archive.jobStates\n            .map(x => (x.state !== newState) ? x : newArchiveJob);\n    archive.jobStates = newJobStates;\n  }\n\n  private update(timesheet: Archive): Promise<void> {\n    return this._databaseService.set(ArchiveConstants.ARCHIVE_DATABASE, ArchiveConstants.ARCHIVE_STORENAME, timesheet);\n  }\n\n  private async updateEngineerStatus(timesheet: Archive, engineerId: string, status: string): Promise<void> {\n    try {\n      const currentArchive = await this.getByDate(moment().format(ARCHIVE_DATE_FORMAT));\n      const sortedArchive = ArrayHelper.sortByColumnDescending<Archive>(currentArchive, \"id\");\n      const sortedArc = sortedArchive.filter(x => x.engineerStatus);\n            if (sortedArc && sortedArc[0] &&\n                // tslint:disable-next-line:max-line-length\n                (moment(sortedArc[0].timestamp).format(ARCHIVE_DATE_FORMAT) === moment().format(ARCHIVE_DATE_FORMAT) && sortedArc[0].engineerStatus === status)) {\n        // last enginner status update is already been make for today's date. so dont do it again.\n        return;\n      }\n      return this._databaseService.set(ArchiveConstants.ARCHIVE_DATABASE, ArchiveConstants.ARCHIVE_STORENAME, timesheet);\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  private async getByJob(jobId: string): Promise<Archive[]> {\n    const archives = await this.getByDate(moment().format(ARCHIVE_DATE_FORMAT));\n    if (archives) {\n      return archives.filter(x => x.jobId === jobId);\n    }\n    return [];\n  }\n\n  private getByDate(date: string): Promise<Archive[]> {\n    return this._databaseService.getAll<Archive>(ArchiveConstants.ARCHIVE_DATABASE, ArchiveConstants.ARCHIVE_STORENAME, \"date\", date);\n  }\n\n  private async createOrOpen(): Promise<void> {\n    if (await this._databaseService.exists(ArchiveConstants.ARCHIVE_DATABASE, ArchiveConstants.ARCHIVE_DATABASE)) {\n      this._databaseService.open(ArchiveConstants.ARCHIVE_DATABASE);\n    } else {\n      await this._databaseService.create(this.getDbSchemDefinition());\n    }\n  }\n\n  private populateParts(job: Job, archiveTaskItem: ArchiveTaskItem): void {\n    if (job.partsDetail && job.partsDetail.partsBasket && job.partsDetail.partsBasket.partsToOrder) {\n      let filteredParts = job.partsDetail.partsBasket.partsToOrder.filter(x => x.taskId === archiveTaskItem.taskId);\n      if (filteredParts) {\n        archiveTaskItem.partsToOrder = [];\n        filteredParts.forEach(part => {\n          let existingPart = archiveTaskItem.partsToOrder.find(x => x.stockRefereceId === part.stockReferenceId);\n          if (existingPart === undefined || existingPart === null) {\n            existingPart = new ArchivePart();\n          }\n          existingPart.description = part.description;\n          existingPart.quantity = part.quantity;\n          existingPart.stockRefereceId = part.stockReferenceId;\n          if (!archiveTaskItem.partsToOrder.find(x => x.stockRefereceId === part.stockReferenceId)) {\n            archiveTaskItem.partsToOrder.push(existingPart);\n          }\n        });\n      }\n    }\n  }\n\n  private populateTasks(job: Job, jobArchive: Archive, jobState: JobState): void {\n    if (jobState === JobState.complete) {\n      if (job && job.tasks && jobArchive) {\n        if (!jobArchive.taskItems) {\n          jobArchive.taskItems = [];\n        }\n        job.tasks.forEach(task => {\n          if (task && task.report) {\n            let archiveTask = jobArchive.taskItems.find(x => x.taskId === task.id);\n            if (archiveTask === undefined || archiveTask === null) {\n              archiveTask = new ArchiveTaskItem();\n              archiveTask.taskId = task.id;\n            }\n            archiveTask.visitStatus = task.status;\n            archiveTask.startTime = task.startTime;\n            archiveTask.endTime = task.endTime;\n            archiveTask.duration = task.workDuration;\n            archiveTask.workReport = task.report;\n            archiveTask.applianceType = task.applianceType;\n            archiveTask.jobType = task.jobType;\n            if (!jobArchive.taskItems.find(x => x.taskId === task.id)) {\n              jobArchive.taskItems.push(archiveTask);\n            }\n            this.populateParts(job, archiveTask);\n          }\n        });\n\n      }\n    }\n  }\n\n  private getDbSchemDefinition(): DatabaseSchema {\n    return new DatabaseSchema(ArchiveConstants.ARCHIVE_DATABASE, ArchiveConstants.ARCHIVE_DATABASE_VERSION, [\n        new DatabaseSchemaStore(ArchiveConstants.ARCHIVE_STORENAME, \"id\", true, [\n          new DatabaseSchemaStoreIndex(\"id\", \"id\", true),\n          new DatabaseSchemaStoreIndex(\"jobId\", \"jobId\", false),\n          new DatabaseSchemaStoreIndex(\"engineerId\", \"engineerId\", false),\n          new DatabaseSchemaStoreIndex(\"date\", \"date\", false)\n        ])\n      ]);\n  }\n}\n"],"sourceRoot":"../../.."}