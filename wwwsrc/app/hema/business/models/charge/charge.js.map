{"version":3,"sources":["hema/business/models/charge/charge.ts"],"names":[],"mappings":"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","file":"charge.js","sourcesContent":["import { ChargeableTask } from \"./chargeableTask\";\nimport { DataState } from \"../dataState\";\nimport * as bignumber from \"bignumber\";\nimport { DataStateProvider } from \"../dataStateProvider\";\n\n// import { Task } from \"../task\";\n\nexport class Charge extends DataStateProvider {\n\n    public static CHARGE_OK: string = \"1\";\n    public static CHARGE_NOT_OK: string = \"2\";\n\n    public jobId: string;\n    public discountAmount: bignumber.BigNumber;\n    public complaintReasonCodeCharge: string;\n    public chargeOption: string;\n    public complaintActionCategoryCharge: string;\n    public remarks: string;\n    public netTotal: bignumber.BigNumber;\n    public chargeTotal: bignumber.BigNumber;\n    public totalVatAmount: bignumber.BigNumber;\n    public tasks: ChargeableTask[];\n    public error: boolean;\n\n    public previousChargeSameAppliance: boolean;\n    public previousChargeSameApplianceConfirmed: boolean;\n\n    constructor() {\n        super(DataState.notVisited, \"charges\");\n        this.tasks = [];\n    }\n\n    public get grossTotal(): bignumber.BigNumber {\n        let total = new bignumber.BigNumber(0);\n\n        for (let task of this.tasks) {\n            if (task.error) {\n                this.error = true;\n                return new bignumber.BigNumber(0);\n            }\n            if (task.grossTotal) {\n                total = total.plus(task.grossTotal);\n            }\n        }\n        return total;\n    }\n\n    public calculatePrimeAndSubCharges(): void {\n\n        const {tasks} = this;\n\n        let [firstTask, ...otherTasks] = this.tasks; // prerequisite api has ordered tasks correctly\n\n        // this scenario if all the tasks are no-charge and non-prime set first one as prime\n        const noChargeTasks = this.tasks.filter(t => t.task.chargeType.substr(0, 2) === \"NC\");\n\n        if (noChargeTasks.length === tasks.length) {\n\n            // if at least one prime found just return as is\n            const existsPrime = tasks.some(t => t.isSubsequent === false);\n\n            if (existsPrime) {\n                return;\n            }\n\n            // else we'll need to flag the first item as prime\n            firstTask.isSubsequent = false;\n            otherTasks.forEach(t => t.isSubsequent = true);\n            return;\n        }\n\n        // single item only\n        if (tasks.length === 1) {\n\n            if (firstTask.labourItem && !firstTask.error) {\n                firstTask.isSubsequent = false;\n            }\n\n            // check no errors for single task, e.g. missing prime charge\n            firstTask.setErrorsPrimeAndSubCharges(true);\n\n            return;\n        }\n        // more than one task\n\n        let mostExpensiveTask: ChargeableTask;\n        let currentMaxPrimeCharge = new bignumber.BigNumber(0);\n        let numberOfPrimeTasks = 0;\n\n        // find out how many prime tasks\n        tasks.forEach(t => {\n            if (t && !t.error) {\n\n                if (t.isSubsequent === false) {\n                    numberOfPrimeTasks += 1;\n                }\n\n                if (t.labourItem && t.labourItem.chargePair && t.labourItem.chargePair.primeCharge.greaterThan(currentMaxPrimeCharge)) {\n                    mostExpensiveTask = t;\n                    currentMaxPrimeCharge = t.labourItem.chargePair.primeCharge;\n                }\n            }\n        });\n\n        // if job has all prime tasks or single task job then no need raise errors if sub charge interval not found\n\n        const ignoreSubsequentCharges = ((numberOfPrimeTasks === tasks.length) || tasks.length === 1);\n\n        // check no errors as result of missing charges in catalog data\n        tasks.map(task => task.setErrorsPrimeAndSubCharges(ignoreSubsequentCharges));\n\n        if (numberOfPrimeTasks === 1) {\n            tasks.forEach(t => {\n                if (!t.useFixedPriceQuotation && !t.error) {\n                    if (t.isSubsequent) {\n                        t.labourItem.netAmount = t.labourItem.chargePair.subsequentCharge;\n                    } else {\n                        t.labourItem.netAmount = t.labourItem.chargePair.primeCharge;\n                    }\n                }\n            });\n            return;\n        }\n\n        if (numberOfPrimeTasks === 0) {\n\n            // df_1775\n            // if exists completed task, flag first completed as already completed and remaining subsequent\n\n            const completedIndex = tasks.findIndex(t => !t.task.isMiddlewareDoTodayTask && t.task.chargeType.substr(0, 2) !== \"NC\");\n\n            if (completedIndex > -1) {\n                tasks.forEach((task, idx) => task.isSubsequent = idx !== completedIndex && task.task.isMiddlewareDoTodayTask);\n                return;\n            }\n            // find the most expensive prime task\n            // mark most expensive item as prime, and use prime charge\n\n            const mostExpensiveIndex = tasks.findIndex(t => t === mostExpensiveTask);\n\n            if (mostExpensiveTask) {\n\n                if (!mostExpensiveTask.useFixedPriceQuotation && !mostExpensiveTask.error) {\n                    tasks[mostExpensiveIndex].labourItem.netAmount = tasks[mostExpensiveIndex].labourItem.chargePair.primeCharge;\n                    tasks[mostExpensiveIndex].isSubsequent = false;\n                }\n\n                // others can be set to supplementary\n\n                for (let i = 0; i < tasks.length; i++) {\n                    if (i !== mostExpensiveIndex) {\n                        if (!tasks[i].useFixedPriceQuotation && !tasks[i].error) {\n                            tasks[i].labourItem.netAmount = tasks[i].labourItem.chargePair.subsequentCharge;\n                            tasks[i].isSubsequent = true;\n\n                        }\n                    }\n                }\n            } else {\n                // so there might be a single chargeable job amongst non-chargeables, we should flag that as prime\n                const findChargeIndex = tasks.findIndex(t => t.task.isCharge);\n                tasks.forEach((t, i) => t.isSubsequent = i !== findChargeIndex);\n            }\n        }\n    }\n\n}\n"],"sourceRoot":"../../../.."}