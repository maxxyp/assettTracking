{"version":3,"sources":["common/resilience/services/resilientService.ts"],"names":[],"mappings":"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","file":"resilientService.js","sourcesContent":["/// <reference path=\"../../../../typings/app.d.ts\" />\r\nimport * as Logging from \"aurelia-logging\";\r\nimport { IEndpointConfiguration } from \"../models/IEndpointConfiguration\";\r\nimport { IConfigurationService } from \"../../core/services/IConfigurationService\";\r\nimport { RetryPayload } from \"../models/retryPayload\";\r\nimport { Guid } from \"../../core/guid\";\r\nimport { IResilientService } from \"./interfaces/IResilientService\";\r\nimport * as moment from \"moment\";\r\nimport { EventAggregator } from \"aurelia-event-aggregator\";\r\nimport { ResilientServiceConstants } from \"../constants/resilientServiceConstants\";\r\nimport { IHttpHeader } from \"../../core/IHttpHeader\";\r\nimport { IHttpHeaderProvider } from \"./interfaces/IHttpHeaderProvider\";\r\nimport { ObjectHelper } from \"../../core/objectHelper\";\r\nimport { IStorageService } from \"../../../hema/business/services/interfaces/IStorageService\";\r\nimport { SuccessLoggingMode } from \"../models/successLoggingMode\";\r\nimport { ResilientHttpClientFactory } from \"./resilientHttpClientFactory\";\r\nimport { ApiException } from \"../apiException\";\r\nimport { IHemaConfiguration } from \"../../../hema/IHemaConfiguration\";\r\nimport { WuaNetworkDiagnostics } from \"../../core/wuaNetworkDiagnostics\";\r\nimport { AnalyticsConstants } from \"../../analytics/analyticsConstants\";\r\nimport { IAnalyticsEvent } from \"../../analytics/IAnalyticsEvent\";\r\n\r\ntype HttpMethod = \"GET\" | \"POST\" | \"PUT\";\r\n\r\nexport abstract class ResilientService implements IResilientService {\r\n    public static UNKNOWN_FLAG: string = \"Unknown\";\r\n    public static HTTP_OK_FLAG: string = \"OK\";\r\n    public static HTTP_FAILED_FLAG: string = \"Failed\";\r\n\r\n    private _configurationName: string;\r\n    private _endpointConfiguration: IEndpointConfiguration;\r\n\r\n    private _eventAggregator: EventAggregator;\r\n    private _httpHeaderProvider: IHttpHeaderProvider;\r\n    private _storageService: IStorageService;\r\n    private _logger: Logging.Logger;\r\n    private _resilientHttpClientFactory: ResilientHttpClientFactory;\r\n    private _wuaNetworkDiagnostics: WuaNetworkDiagnostics;\r\n    private _payloads: RetryPayload[];\r\n    private _isRetryInProgress: boolean;\r\n    private _configurationService: IConfigurationService;\r\n\r\n    constructor(configurationService: IConfigurationService,\r\n        configurationName: string,\r\n        storageService: IStorageService,\r\n        eventAggregator: EventAggregator,\r\n        httpHeaderProvider: IHttpHeaderProvider,\r\n        resilientHttpClientFactory: ResilientHttpClientFactory,\r\n        wuaNetworkDiagnostics?: WuaNetworkDiagnostics) {\r\n        this._configurationName = configurationName;\r\n        this._storageService = storageService;        \r\n        this._eventAggregator = eventAggregator;\r\n        this._httpHeaderProvider = httpHeaderProvider;\r\n        this._logger = Logging.getLogger(\"ResilientService\");\r\n        this._resilientHttpClientFactory = resilientHttpClientFactory;\r\n        this._wuaNetworkDiagnostics = wuaNetworkDiagnostics;\r\n        this._configurationService = configurationService;\r\n\r\n        this._endpointConfiguration = this._configurationService.getConfiguration<IEndpointConfiguration>(configurationName);\r\n        if (!this._endpointConfiguration) {\r\n            throw new Error(\"Missing endpoint configuration \" + configurationName);\r\n        }\r\n    }\r\n\r\n    public getUnsentPayloads(): Promise<RetryPayload[]> {\r\n        return Promise.resolve(this.getPayloadsReference());\r\n    }\r\n\r\n    public async clearUnsentPayloads(): Promise<void> {\r\n        this._payloads = [];\r\n        this.commitRetryPayloads();\r\n    }\r\n\r\n    public sendAllRetryPayloads(): Promise<void> {\r\n        return this.flushRetryQueue();\r\n    }\r\n\r\n    public isRetryInProgress(): boolean {\r\n        return this._isRetryInProgress;\r\n    }\r\n\r\n    public isInternetConnected(): boolean {\r\n        return !!this._wuaNetworkDiagnostics && this._wuaNetworkDiagnostics.isInternetConnected();\r\n    }\r\n\r\n    public getConfigurationName(): string {\r\n        return this._configurationName;\r\n    }\r\n\r\n    protected getData<T>(routeName: string, params: { [id: string]: any }, breakCache?: boolean): Promise<T> {\r\n        return this.makeImmediateCall<void, T>(\"GET\", routeName, params, null, breakCache);\r\n    }\r\n\r\n    protected postData<T, V>(routeName: string, params: { [id: string]: any }, data: T): Promise<V> {\r\n        return this.makeImmediateCall<T, V>(\"POST\", routeName, params, data);\r\n    }\r\n\r\n    protected putData<T, V>(routeName: string, params: { [id: string]: any }, data: T): Promise<V> {\r\n        return this.makeImmediateCall<T, V>(\"PUT\", routeName, params, data);\r\n    }\r\n\r\n    protected postDataResilient(routeName: string, params: { [id: string]: any }, data: any): Promise<void> {\r\n        return this.makeQueuedCall(\"POST\", routeName, params, data);\r\n    }\r\n\r\n    protected putDataResilient(routeName: string, params: { [id: string]: any }, data: any): Promise<void> {\r\n        return this.makeQueuedCall(\"PUT\", routeName, params, data);\r\n    }\r\n\r\n    private makeImmediateCall<T, V>(httpMethod: HttpMethod, routeName: string, params: { [id: string]: any }, data?: T, breakCache?: boolean): Promise<V> {\r\n\r\n        ObjectHelper.sanitizeObjectStringsForHttp(data);\r\n\r\n        let p = this._httpHeaderProvider\r\n            ? this._httpHeaderProvider.getHeaders(routeName)\r\n            : Promise.resolve([]);\r\n\r\n        return p\r\n            .then(headers => this.sendPayload(httpMethod, routeName, headers, params, null, data, breakCache))\r\n            .then(result => {\r\n                this.flushRetryQueue(); // do not wait on this promise\r\n                return result;\r\n            })\r\n            .catch((error) => {\r\n                this._logger.warn(\"Error\", { routeName, input: { method: \"GET\", params, breakCache }, error });\r\n                throw error;\r\n            });\r\n    }\r\n\r\n    private makeQueuedCall(httpMethod: HttpMethod, routeName: string, params: { [id: string]: any }, data?: any, breakCache?: boolean): Promise<any> {\r\n\r\n        ObjectHelper.sanitizeObjectStringsForHttp(data);\r\n\r\n        let p = this._httpHeaderProvider\r\n            ? this._httpHeaderProvider.getHeaders(routeName)\r\n            : Promise.resolve([]);\r\n\r\n        return p\r\n            .then(headers => {\r\n                let retryPayload = this.buildRetryPayload(httpMethod, routeName, headers, params, data);\r\n                this.addNewRetryPayload(retryPayload);\r\n            })\r\n            .then(() => {\r\n                /* do not wait on this promise as we do not want to make any subsequent business\r\n                    logic to wait for the flushing to complete - it may take a loooong time */\r\n                this.flushRetryQueue();\r\n            });\r\n    }\r\n\r\n    private async sendPayload(httpMethod: HttpMethod, routeName: string,\r\n        headers: IHttpHeader[], params: { [id: string]: any }, retryGuid: Guid, data?: any, breakCache?: boolean): Promise<any> {\r\n        let guid = Guid.newGuid();\r\n\r\n        let routeConfig = this._endpointConfiguration.routes.find(route => route.route === routeName);\r\n        let clientConfig = this._endpointConfiguration.clients.find(client => client.name === routeConfig.client);\r\n        let { root } = clientConfig;\r\n        let { path } = routeConfig;\r\n\r\n        let successLoggingMode = routeConfig.successLoggingMode || SuccessLoggingMode.log; // default to full logging\r\n        let inputLoggingParams: any = { method: httpMethod, root, path, params, breakCache, headers, data };\r\n        let startTime: number;\r\n\r\n        const config = this._configurationService.getConfiguration<IHemaConfiguration>();\r\n        const resilienceSendAnalyticsOnSuccess = config.resilienceSendAnalyticsOnSuccess;\r\n        try {\r\n            let resolveHttpMethodAndSend = (): Promise<any> => {\r\n                let httpClient = this._resilientHttpClientFactory.getHttpClient(clientConfig);\r\n                switch (httpMethod) {\r\n                    case \"GET\":\r\n                        return httpClient.getData(root, path, params, breakCache, headers);\r\n                    case \"POST\":\r\n                        return httpClient.postData(root, path, params, data, headers);\r\n                    case \"PUT\":\r\n                        return httpClient.putData(root, path, params, data, headers);\r\n                    default:\r\n                        throw \"Unknown HttpMethod verb: \" + httpMethod;\r\n                }\r\n            };\r\n\r\n            if (successLoggingMode !== SuccessLoggingMode.dontLog) {\r\n                this._logger.warn(\"Attempt\", { guid, retryGuid });\r\n            }\r\n\r\n            startTime = Date.now();\r\n            let result = await resolveHttpMethodAndSend();\r\n\r\n            if (result && result.status && result.error) {\r\n                throw new ApiException(this, \"sendPayload\", \"Middleware 200 error - status: {0}, error - {1}\",\r\n                    [result.status, result.error], result, result.status);\r\n            }\r\n\r\n            let elapsedTimeMs = Date.now() - startTime;\r\n\r\n            if (resilienceSendAnalyticsOnSuccess && this._endpointConfiguration.sendAnalyticsOnSuccess) {\r\n                this.sendAnalytics(routeName, ResilientService.HTTP_OK_FLAG, elapsedTimeMs);\r\n            }\r\n\r\n            let logObject = {\r\n                guid,\r\n                routeName,\r\n                input: inputLoggingParams,\r\n                result,\r\n                retryGuid,\r\n                elapsedTimeMs\r\n            };\r\n\r\n            switch (successLoggingMode) {\r\n                case SuccessLoggingMode.log:\r\n                    this._logger.warn(\"Success\", logObject);\r\n                    break;\r\n                case SuccessLoggingMode.logWithoutResponse:\r\n                    logObject.result = \"not logged\";\r\n                    this._logger.warn(\"Success\", logObject);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n\r\n            return result;\r\n\r\n        } catch (exception) {\r\n            let elapsedTimeMs = Date.now() - startTime;\r\n            exception = exception || ResilientService.UNKNOWN_FLAG;\r\n\r\n            let httpStatusCode;\r\n            let errorMessage = exception.toString();\r\n\r\n            if (exception instanceof ApiException) {\r\n                let apiException = <ApiException>exception;\r\n                httpStatusCode = apiException.httpStatusCode;\r\n                errorMessage = `${apiException.reference}: ${apiException.resolvedMessage}`;\r\n            }\r\n\r\n            // if we have not got an httpStatusCode then we may be having network issues (i.e. a response as not received), so gather info\r\n            let networkDiagnostics = (!httpStatusCode && this._wuaNetworkDiagnostics)\r\n                ? this._wuaNetworkDiagnostics.getDiagnostics()\r\n                : undefined;\r\n\r\n            if (networkDiagnostics) {\r\n                httpStatusCode = ResilientService.HTTP_FAILED_FLAG + \"-\" + networkDiagnostics.connection;\r\n            }\r\n\r\n            httpStatusCode = httpStatusCode || ResilientService.UNKNOWN_FLAG;\r\n\r\n            if (this._configurationName === \"whoAmIServiceEndpoint\") {\r\n                this.sendAnalytics(routeName, httpStatusCode, elapsedTimeMs);\r\n            }\r\n\r\n            let logObject = {\r\n                guid,\r\n                routeName,\r\n                input: inputLoggingParams,\r\n                result: errorMessage,\r\n                retryGuid,\r\n                elapsedTimeMs,\r\n                httpStatusCode,\r\n                networkDiagnostics\r\n            };\r\n\r\n            this._logger.error(\"Error\", logObject);\r\n            throw exception;\r\n        }\r\n    }\r\n\r\n    private sendAnalytics(routeName: string, httpStatusCode: string, elapsedTimeMs: number): void {\r\n        this._eventAggregator.publish(AnalyticsConstants.ANALYTICS_EVENT, <IAnalyticsEvent>{\r\n            category: AnalyticsConstants.HTTP_RESULT,\r\n            action: routeName,\r\n            label: httpStatusCode,\r\n            metric: elapsedTimeMs\r\n        });\r\n    }\r\n\r\n    private buildRetryPayload(httpMethod: HttpMethod, routeName: string, headers: IHttpHeader[], params: { [id: string]: any }, data: any): RetryPayload {\r\n        let retryPayload: RetryPayload = new RetryPayload();\r\n        retryPayload.correlationId = Guid.newGuid();\r\n        retryPayload.createdTime = new Date();\r\n        retryPayload.httpMethod = httpMethod;\r\n        retryPayload.routeName = routeName;\r\n        retryPayload.headers = headers;\r\n        retryPayload.params = params;\r\n        retryPayload.data = data;\r\n\r\n        const config = this._configurationService.getConfiguration<IHemaConfiguration>();\r\n        const unSentPayloadExpiryMinutes = config.unSentPayloadExpiryMinutes;\r\n\r\n        if (!!unSentPayloadExpiryMinutes && unSentPayloadExpiryMinutes > 0) {\r\n            retryPayload.expiryTime = moment().add(unSentPayloadExpiryMinutes, \"minutes\").toDate();\r\n        }    \r\n\r\n        retryPayload.lastFailureMessage = \"\";\r\n        retryPayload.failureWithoutStatusCount = 0;\r\n        retryPayload.failureWithStatusCount = 0;\r\n\r\n        return retryPayload;\r\n    }\r\n\r\n    private async flushRetryQueue(): Promise<void> {\r\n        const config = this._configurationService.getConfiguration<IHemaConfiguration>();\r\n        const retryIntervals = config.resilienceRertyIntervals || [];\r\n        const resilienceFlushSkipFailures =  config.resilienceFlushSkipFailures;\r\n        // if the user is at (say) the end of day, and there is a particular call that is permanently\r\n        //  not working, all subsequent calls we also be blocked. isHardFlush will flush as normal but continue\r\n        //  on through the queue regardless if each or any call 500s etc.\r\n        if (this._isRetryInProgress) {\r\n            return;\r\n        }\r\n        this._isRetryInProgress = true;\r\n\r\n        let getPayload = (index: number) => {\r\n            // rather than take a local snapshot of payloads, it's probably better to keep accessing\r\n            //  the underlying payloads via this.getUnsentPayloads() because this.retryPayload directly\r\n            //  updates the underlying storage to e.g. splice out successful records.  If we had a local\r\n            //  copy we'd have to duplicate that logic.\r\n            let payloads = this.getPayloadsReference();\r\n            return payloads\r\n                && (payloads.length >= index + 1)\r\n                && { index, payload: payloads[index] };\r\n        };\r\n\r\n        let pollingRetryAPayload = async (retryPayload: RetryPayload): Promise<boolean> => {            \r\n            let retryDurations = [...retryIntervals].reverse(); // reverse so we pop from the start\r\n\r\n            while (true) {\r\n                let isSuccess = await this.retryPayload(retryPayload);\r\n                if (isSuccess) {\r\n                    return true;\r\n                }\r\n\r\n                let delay = retryDurations.pop();\r\n                if (delay === undefined) {\r\n                    // there are no more intervals left to wait so break out\r\n                    break;\r\n                }\r\n\r\n                await Promise.delay(delay);\r\n            }\r\n            return false;\r\n        };\r\n\r\n        let nextIndexToPick = 0;\r\n        while (true) {\r\n            let payload = getPayload(nextIndexToPick);\r\n            if (!payload) {\r\n                break;\r\n            }\r\n\r\n            let isSuccess = await pollingRetryAPayload(payload.payload);\r\n            if (isSuccess) {\r\n                // all good, so just loop and take from the top of the queue again\r\n            } else {\r\n                if (resilienceFlushSkipFailures) {\r\n                    // failed, but we are not going to let the top retry payload block the rest\r\n                    nextIndexToPick += 1;\r\n                } else {\r\n                    // failed and we need to block to ensure payloads always go out in order\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._isRetryInProgress = false;\r\n        // one more call to allow subscribers to detect the end of the global retry\r\n        this._eventAggregator.publish(ResilientServiceConstants.UNSENT_PAYLOADS_UPDATES, this._configurationName);\r\n    }\r\n\r\n    private async retryPayload(retryPayload: RetryPayload): Promise<boolean> {\r\n        retryPayload.isRetrying = true;\r\n        retryPayload.lastFailureMessage = \"\";\r\n        this.saveChangedRetryPayload(retryPayload);\r\n\r\n        try {\r\n            await this.sendPayload(retryPayload.httpMethod,\r\n                retryPayload.routeName,\r\n                retryPayload.headers,\r\n                retryPayload.params,\r\n                retryPayload.correlationId,\r\n                retryPayload.data);\r\n            this.removeSuccessfulRetryPayload(retryPayload);\r\n            return true;\r\n        } catch (err) {\r\n            retryPayload.isRetrying = false;\r\n            retryPayload.lastFailureMessage = err && err.toString();\r\n            retryPayload.lastRetryTime = new Date();\r\n            let statusCode = err && (err as ApiException).httpStatusCode;\r\n            if (statusCode) {\r\n                retryPayload.lastKnownFailureStatus = statusCode;\r\n                retryPayload.failureWithStatusCount += 1;\r\n            } else {\r\n                retryPayload.failureWithoutStatusCount += 1;\r\n            }\r\n            this.saveChangedRetryPayload(retryPayload);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private addNewRetryPayload(retryPayload: RetryPayload): void {\r\n        let payloads = this.getPayloadsReference();\r\n        payloads.push(retryPayload);\r\n        this.commitRetryPayloads();\r\n    }\r\n\r\n    private removeSuccessfulRetryPayload(retryPayload: RetryPayload): void {\r\n        let payloads = this.getPayloadsReference();\r\n        let payloadIndexToRemove = payloads.findIndex(payload => payload.correlationId === retryPayload.correlationId);\r\n        if (payloadIndexToRemove !== -1) {\r\n            payloads.splice(payloadIndexToRemove, 1);\r\n            this.commitRetryPayloads();\r\n        }\r\n    }\r\n\r\n    private saveChangedRetryPayload(retryPayload: RetryPayload): void {\r\n        let payloads = this.getPayloadsReference();\r\n        let payloadIndexToSave = payloads.findIndex(payload => payload.correlationId === retryPayload.correlationId);\r\n        if (payloadIndexToSave !== -1) {\r\n            payloads[payloadIndexToSave] = retryPayload;\r\n            this.commitRetryPayloads();\r\n        }\r\n    }\r\n\r\n    private getPayloadsReference(): RetryPayload[] {\r\n        // if we had an initialise event/method, then we'd be able to simplyfy all of this\r\n        if (!this._payloads) {\r\n            this._payloads = [];\r\n\r\n            let resiliencePayloads = this._storageService.getResilienceRetryPayloads(this._configurationName.toUpperCase()) || [];\r\n            if (resiliencePayloads.length) {\r\n                // if we have payloads in storage when we are starting the app for the first time, reset any retrying flags set as true\r\n                resiliencePayloads.forEach(payload => payload.isRetrying = false);\r\n                this._payloads = [...resiliencePayloads, ...this._payloads];\r\n                this.commitRetryPayloads();\r\n            }\r\n        }\r\n\r\n        let timeNow = new Date().getTime();\r\n        let haveExpiredPayloads = this._payloads.some(retryPayload => !!retryPayload.expiryTime && retryPayload.expiryTime.getTime() < timeNow);\r\n        if (haveExpiredPayloads) {\r\n            this._payloads = this._payloads.filter(retryPayload => !!retryPayload.expiryTime && retryPayload.expiryTime.getTime() >= timeNow);\r\n            this.commitRetryPayloads();\r\n        }\r\n\r\n        return this._payloads;\r\n    }\r\n\r\n    private commitRetryPayloads(): void {\r\n        this._storageService.setResilienceRetryPayloads(this._configurationName.toUpperCase(), this._payloads);\r\n        this._eventAggregator.publish(ResilientServiceConstants.UNSENT_PAYLOADS_UPDATES, this._configurationName);\r\n    }\r\n}\r\n"],"sourceRoot":"../../.."}