"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Ajv = require("ajv");
var chai_1 = require("chai");
var fs_1 = require("fs");
var path_1 = require("path");
var TJS = require("../typescript-json-schema");
var ajv = new Ajv();
var metaSchema = require("ajv/lib/refs/json-schema-draft-04.json");
ajv.addMetaSchema(metaSchema, "http://json-schema.org/draft-04/schema#");
var BASE = "test/programs/";
function assertSchema(group, type, settings, compilerOptions) {
    if (settings === void 0) { settings = {}; }
    it(group + " should create correct schema", function () {
        if (!("required" in settings)) {
            settings.required = true;
        }
        var actual = TJS.generateSchema(TJS.getProgramFromFiles([path_1.resolve(BASE + group + "/main.ts")], compilerOptions), type, settings);
        var file = fs_1.readFileSync(BASE + group + "/schema.json", "utf8");
        var expected = JSON.parse(file);
        chai_1.assert.isObject(actual);
        chai_1.assert.deepEqual(actual, expected, "The schema is not as expected");
        if (actual !== null) {
            ajv.validateSchema(actual);
            chai_1.assert.equal(ajv.errors, null, "The schema is not valid");
        }
    });
}
exports.assertSchema = assertSchema;
describe("interfaces", function () {
    it("should return an instance of JsonSchemaGenerator", function () {
        var program = TJS.getProgramFromFiles([path_1.resolve(BASE + "comments/main.ts")]);
        var generator = TJS.buildGenerator(program);
        chai_1.assert.instanceOf(generator, TJS.JsonSchemaGenerator);
        if (generator !== null) {
            chai_1.assert.doesNotThrow(function () { return generator.getSchemaForSymbol("MyObject"); });
            chai_1.assert.doesNotThrow(function () { return generator.getSchemaForSymbol("Vector3D"); });
            var symbols = generator.getUserSymbols();
            chai_1.assert(symbols.indexOf("MyObject") > -1);
            chai_1.assert(symbols.indexOf("Vector3D") > -1);
        }
    });
    it("should output the schemas set by setSchemaOverride", function () {
        var program = TJS.getProgramFromFiles([path_1.resolve(BASE + "interface-multi/main.ts")]);
        var generator = TJS.buildGenerator(program);
        chai_1.assert(generator !== null);
        if (generator !== null) {
            var schemaOverride = { type: "string" };
            generator.setSchemaOverride("MySubObject", schemaOverride);
            var schema = generator.getSchemaForSymbol("MyObject");
            chai_1.assert.deepEqual(schema.definitions["MySubObject"], schemaOverride);
        }
    });
});
describe("schema", function () {
    describe("type aliases", function () {
        assertSchema("type-alias-single", "MyString");
        assertSchema("type-alias-single-annotated", "MyString");
        assertSchema("type-aliases", "MyObject", {
            aliasRef: true
        });
        assertSchema("type-aliases-fixed-size-array", "MyFixedSizeArray");
        assertSchema("type-aliases-multitype-array", "MyArray");
        assertSchema("type-aliases-local-namsepace", "MyObject", {
            aliasRef: true
        });
        assertSchema("type-aliases-alias-ref", "MyAlias", {
            aliasRef: true,
            topRef: false
        });
        assertSchema("type-aliases-recursive-object-topref", "MyObject", {
            aliasRef: true,
            topRef: true
        });
        assertSchema("type-no-aliases-recursive-topref", "MyAlias", {
            aliasRef: false,
            topRef: true
        });
    });
    describe("enums", function () {
        assertSchema("enums-string", "MyObject");
        assertSchema("enums-number", "MyObject");
        assertSchema("enums-number-initialized", "Enum");
        assertSchema("enums-compiled-compute", "Enum");
        assertSchema("enums-mixed", "MyObject");
        assertSchema("enums-value-in-interface", "MyObject");
    });
    describe("unions and intersections", function () {
        assertSchema("type-union", "MyObject");
        assertSchema("type-intersection", "MyObject", {
            noExtraProps: true
        });
        assertSchema("type-union-tagged", "Shape");
        assertSchema("type-aliases-union-namespace", "MyModel");
    });
    describe("annotations", function () {
        assertSchema("annotation-default", "MyObject");
        assertSchema("annotation-ref", "MyObject");
        assertSchema("annotation-tjs", "MyObject");
        assertSchema("annotation-id", "MyObject");
        assertSchema("typeof-keyword", "MyObject", { typeOfKeyword: true });
        assertSchema("user-validation-keywords", "MyObject", {
            validationKeywords: ["chance", "important"]
        });
    });
    describe("generics", function () {
        assertSchema("generic-simple", "MyObject");
        assertSchema("generic-arrays", "MyObject");
        assertSchema("generic-multiple", "MyObject");
        assertSchema("generic-multiargs", "MyObject");
        assertSchema("generic-anonymous", "MyObject");
        assertSchema("generic-recursive", "MyObject", {
            topRef: true
        });
        assertSchema("generic-hell", "MyObject");
    });
    describe("comments", function () {
        assertSchema("comments", "MyObject");
        assertSchema("comments-override", "MyObject");
    });
    describe("types", function () {
        assertSchema("force-type", "MyObject");
        assertSchema("force-type-imported", "MyObject");
        assertSchema("type-anonymous", "MyObject");
        assertSchema("type-primitives", "MyObject");
        assertSchema("type-nullable", "MyObject");
        assertSchema("type-function", "MyObject");
    });
    describe("class and interface", function () {
        assertSchema("class-single", "MyObject");
        assertSchema("class-extends", "MyObject");
        assertSchema("interface-single", "MyObject");
        assertSchema("interface-multi", "MyObject");
        assertSchema("interface-extends", "MyObject");
        assertSchema("interface-recursion", "MyObject", {
            topRef: true
        });
        assertSchema("module-interface-single", "MyObject");
        assertSchema("ignored-required", "MyObject");
    });
    describe("maps and arrays", function () {
        assertSchema("array-readonly", "MyReadOnlyArray");
        assertSchema("array-types", "MyArray");
        assertSchema("map-types", "MyObject");
        assertSchema("extra-properties", "MyObject");
    });
    describe("string literals", function () {
        assertSchema("string-literals", "MyObject");
        assertSchema("string-literals-inline", "MyObject");
    });
    describe("namespaces", function () {
        assertSchema("namespace", "Type");
        assertSchema("namespace-deep-1", "RootNamespace.Def");
        assertSchema("namespace-deep-2", "RootNamespace.SubNamespace.HelperA");
    });
    describe("other", function () {
        assertSchema("array-and-description", "MyObject");
        assertSchema("optionals", "MyObject");
        assertSchema("optionals-derived", "MyDerived");
        assertSchema("strict-null-checks", "MyObject", undefined, {
            strictNullChecks: true
        });
        assertSchema("imports", "MyObject");
        assertSchema("generate-all-types", "*");
        assertSchema("private-members", "MyObject", {
            excludePrivate: true
        });
    });
});
//# sourceMappingURL=schema.test.js.map